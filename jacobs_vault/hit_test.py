# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/01_HitTest.ipynb (unless otherwise specified).

__all__ = ['DAY_FILE_PATH', 'COLUMNS', 'DTYPES', 'dates', 'load_day_file', 'df', 'test_skyfield',
           'satellite_alt_az_days', 'df_alt_az_days', 'hit_quality', 'df_hit_quality', 'df_alt_az_days_visible', 'fig']

# Cell
# Supposed to be "hide" but that keeps the module from having imports.

from datetime import datetime
from dateutil import tz
from skyfield.api import EarthSatellite
from skyfield.api import Topos, load
import math
import pandas as pd
import plotly.express as px
import numpy as np

# Cell
DAY_FILE_PATH="data/VAULT_Data/TLE_daily"
#DAY_FILE_PATH="/share/nas2/data/vault/TLE_daily"


# Cell
COLUMNS = ["satellite", "day_dt", "day", "tle_dt", "tle_ts", "line1", "line2"]
# DTYPES = [str, str, int, str, int, str, str]
DTYPES = {'satellite': 'uint16', # observed values are ints in 5..41678, so 0..65535 is good
          'day_dt': 'str',       # here a single date, but generally datetime: PARSE
          'day': 'uint16',       # here a single value 6026, too big for uint8, but 16 is good
          'tle_dt': 'str',       # again, PARSE AS DATETIME
          'tle_ts': 'uint32',    # large ints, but < 4294967295. We could compress more, but... meh
          'line1': 'string',     # 12K unique 80-char TLE strings. Category wd give tiny compression.
          'line2': 'string'}     # In theory "string" is better than "object". Not seeing it here.

dates = ['day_dt', 'tle_dt']


# Cell
def load_day_file(dt, folder=DAY_FILE_PATH):
    df_path = "%s/%4d/%02d/%02d.tab.gz"%(folder, dt.year, dt.month, dt.day)
    print(df_path)
    df = pd.read_csv(df_path,
                     names=COLUMNS, sep='\t', compression='gzip',
                     dtype=DTYPES,
                     parse_dates=dates,
                     infer_datetime_format=True)
    return df


# Cell
df = load_day_file(datetime(2016, 6, 30))
df.count()
df.head()


# Cell
pd.DataFrame([df.dtypes, df.memory_usage(index=False, deep=True)], index=['Dtype', 'Mem']).T

# Cell
df.info()

# Cell
print(df.iloc[3]["line1"])
print(df.iloc[3]["line2"])


# Cell
def test_skyfield():
    lat =  45.0
    lon = -176.0
    earth_position = Topos(lat, lon)

    ts = load.timescale()
    t = ts.utc(datetime(2016, 6, 30).replace(tzinfo=tz.tzutc()))

    line1="1 10000U 77034A   16182.45131225 -.00000171  00000-0  00000+0 0  1275"
    line2="2 10000  15.5820 331.7785 0019081 259.0540  28.2803  0.96674507130362"
    satellite = EarthSatellite(line1, line2, '77034', ts)

    difference = satellite - earth_position

    topocentric = difference.at(t)
    alt, az, distance = topocentric.altaz()

    print(f'{alt.degrees:.1f}ยบ, {az.degrees:.1f}ยบ, {distance.km:.1f}km')
#
test_skyfield()

# Cell
pd.DataFrame([51.5, 189, 2.3], index=['alt','az','days'])

# Cell
def satellite_alt_az_days(dt: datetime, lat: float, lon: float):
    '''Load tracks for day {dt} and return altitiude, azimuth, and timesep from {dt} for each row.

    '''
    earth_position = Topos(lat, lon)

    ts = load.timescale()
    t = ts.utc(dt.replace(tzinfo=tz.tzutc()))

    def eval_tle(row):
        '''Extract satellite info from line1/line2/tle_dt.

        Returns alt, az, and (days between dt and each row).

        TODO: Currently only works for `apply(raw=False)`.

        '''
        try:
            satellite = EarthSatellite(row['line1'], row['line2'], 'x', ts)
            delta_days = abs(dt - row['tle_dt'])
        except IndexError:
            # `apply(raw=True)` sends arrays instead of Series
            satellite = EarthSatellite(row[5], row[6], 'x', ts)
            delta_days = abs(dt - row[3])
        topocentric = (satellite - earth_position).at(t)
        alt, az, distance = topocentric.altaz()
        return pd.Series([alt.degrees, az.degrees, delta_days])

    df = load_day_file(dt)
    df_alt_az_days = pd.DataFrame(df.apply(eval_tle, axis=1, raw=False))
    df_alt_az_days.columns = ["altitude", "azimuth", "days"]
    #df_alt_az_days.reindex()
    return df_alt_az_days
#

df_alt_az_days = satellite_alt_az_days(datetime(2016, 6, 30), 45.0, -176.0)

# Cell
df_alt_az_days.count()

# Cell
df_alt_az_days.head()

# Cell
def hit_quality(df_alt_az_days):
    """Return hit/miss and quality as time proximity.

    Parameters
    ----------
    `df_alt_az_days`: Dataframe returned by `satellite_alt_az_days`.

    Returns
    --------
    Dataframe with columns ["hit", "miss"]. Each row will have exactly one filled, with
    a string denoting how recent the pass was, e.g. "excellent", "good", "poor", "stale".

    """

    def eval_quality(row):
        """Inner function to be `apply`d to a dataframe."""
        ser = None
        days = row[2].days
        altitude = row[0]
        if days <= 2.0:
            if altitude > 0.0:
                vals = ["excellent", math.nan]
            else:
                vals = [math.nan, "excellent"]
        elif days <= 14.0:
            if altitude > 0.0:
                vals = ["good", math.nan]
            else:
                vals = [math.nan, "good"]
        elif days <= 56.0:
            if altitude > 0.0:
                vals = ["poor", math.nan]
            else:
                vals = [math.nan, "poor"]
        else:
            vals = [math.nan, "stale"]

        return pd.Series(vals)

    df_hit_quality = pd.DataFrame(df_alt_az_days.apply(eval_quality, axis=1))
    df_hit_quality.columns = ["hit", "miss"]
    return df_hit_quality
#

# Cell
df_hit_quality = hit_quality(df_alt_az_days)

# Cell
df_hit_quality["hit"].value_counts()

# Cell
df_hit_quality["miss"].value_counts()

# Cell
pd.concat([df_hit_quality["hit"].value_counts(), df_hit_quality["miss"].value_counts()], axis=1, sort=False)

# Cell
df_alt_az_days_visible = df_alt_az_days[df_alt_az_days["altitude"]>0].copy()

# Cell
df_alt_az_days_visible.count()

# Cell
df_alt_az_days_visible.head(5)

# Cell
df_alt_az_days_visible["color"] = 2
df_alt_az_days_visible.loc[(df_alt_az_days_visible["days"].dt.days <= 14.0), "color"] = 1
df_alt_az_days_visible.loc[(df_alt_az_days_visible["days"].dt.days <= 2.0), "color"] = 0
df_alt_az_days_visible["R"] = 90.0 - df_alt_az_days_visible["altitude"]
#fig = px.scatter_polar(df_alt_az_days_visible, r="R", theta="azimuth", color_discrete_sequence=['black'])
fig = px.scatter_polar(df_alt_az_days_visible, r="R", theta="azimuth", color="color")
fig.show()

