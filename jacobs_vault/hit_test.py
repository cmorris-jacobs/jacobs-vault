# AUTOGENERATED! DO NOT EDIT! File to edit: nbs/05_HitTest.ipynb (unless otherwise specified).

__all__ = ['COLUMNS', 'DTYPES', 'DATE_COLS', 'DAY_FILE_PATH', 'get_qvals', 'HORIZON', 'HitTest']

# Cell

# Requires modules in ../jacobs_vault be available. Either:
#    ln -s nbs/jacobs_vault -> jacobs_vault
# or:
#    in each notebook `import sys; sys.path.append('..')`
# or:
#    add .. to PYTHONPATH.

from .starmap import starmap  # Plotting fn

from datetime import datetime
from dateutil import tz
from skyfield.api import EarthSatellite
from skyfield.api import Topos, load
import math
import pandas as pd
import numpy as np

# Cell
COLUMNS = ["satellite", "day_dt", "day", "tle_dt", "tle_ts", "line1", "line2"]
# DTYPES = [str, str, int, str, int, str, str]
DTYPES = {'satellite': 'uint16', # observed values are ints in 5..41678, so 0..65535 is good
          'day_dt': 'str',       # here a single date, but generally datetime: PARSE
          'day': 'uint16',       # here a single value 6026, too big for uint8, but 16 is good
          'tle_dt': 'str',       # again, PARSE AS DATETIME
          'tle_ts': 'uint32',    # large ints, but < 4294967295. We could compress more, but... meh
          'line1': 'string',     # 12K unique 80-char TLE strings. Category wd give tiny compression.
          'line2': 'string'}     # In theory "string" is better than "object". Not seeing it here.

DATE_COLS = ['day_dt', 'tle_dt']

# Where to look for the TLE dayfiles.
# Symlink ../data to the actual data.
DAY_FILE_PATH="../data/VAULT_Data/TLE_daily"


# Cell

# Set horizon in degrees. Suggested: 0º or 14.6º.
HORIZON = 14.6

# Define cutoffs for TLE track quality, as TLE age in days
EXCELLENT, GOOD, POOR = 2, 14, 56

def get_qvals(𝚫t: int, alt: float, 𝜃:float=HORIZON):
    """Get quality vals for raw 𝚫t [days].

    Returns Series (alt, az, 𝚫t) in units (º,º, days)

    Params
    ------
        𝚫t - age of TLE in days. Int or flot.
        alt - altitude above horizon
        𝜃 - minimum alt in degrees to count as a hit (Default HORIZON)

    """

    if 𝚫t <= EXCELLENT:
        if alt.degrees > 𝜃:
            qvals = ["Excellent", math.nan]
        else:
            qvals = [math.nan, "Excellent"]
    elif 𝚫t <= GOOD:
        if alt.degrees > 0.0:
            qvals = ["Good", math.nan]
        else:
            qvals = [math.nan, "Good"]
    elif 𝚫t <= POOR:
        if alt.degrees > 0.0:
            qvals = ["Poor", math.nan]
        else:
            qvals = [math.nan, "Poor"]
    else:
        qvals = [math.nan, "Stale"]

    return qvals

#

# Cell

class HitTest:
    """ Counts the satellites that are visible at a given point on the globe at a
    given time, and returns counts classified by data quality and
    latitude, azimuth, hit_quality, radius for visible satellites
    """
    def __init__(self, dt:datetime,
                 day_file_base_path:str=DAY_FILE_PATH,
                 𝜃:float=HORIZON):
        """Look for and load TLE datafile for date {dt}."""

        df_path = "%s/%4d/%02d/%02d.tab.gz" % (day_file_base_path, dt.year, dt.month, dt.day)
        print(f"Trying to load {df_path}")
        df = pd.read_csv(df_path,
                         names=COLUMNS, sep='\t', compression='gzip',
                         dtype=DTYPES,
                         parse_dates=DATE_COLS,
                         infer_datetime_format=True)
        self.df_day_tle = df.drop_duplicates()
        self.𝜃 = 𝜃
        self.dt = dt
    #


    def satellite_alt_az_days(self, _t0: datetime, lat: float, lon: float):
        '''Load tracks for day {_t0} and return altº, azº, and 𝚫t [days]
        for each row.

        Usage eg: satellite_alt_az_days(datetime(2016, 6, 30), 45.0, -176.0)

        '''
        earth_position = Topos(lat, lon)

        ts = load.timescale()
        t = ts.utc(_t0.replace(tzinfo=tz.tzutc()))

        def eval_tle(row):
            '''Extract satellite info from line1/line2/tle_dt.

            Returns alt, az, and (days between dt and each row).
            Inherits {ts}, {t}, and {earth_position} values at function definition.

            TODO: Currently only works for `apply(raw=False)`.

            '''
            try:
                satellite = EarthSatellite(row['line1'], row['line2'], 'x', ts)
                𝚫t = abs(_t0 - row['tle_dt']).days
            except IndexError:
                # `apply(raw=True)` sends arrays instead of Series
                satellite = EarthSatellite(row[5], row[6], 'x', ts)
                𝚫t = abs(_t0 - row[3]).days
            topocentric = (satellite - earth_position).at(t)
            alt, az, distance = topocentric.altaz()
            qvals = get_qvals(𝚫t, alt)
            return pd.Series([alt.degrees, az.degrees, 𝚫t] + qvals)

        _ = self.df_day_tle.apply(eval_tle, axis=1, raw=False)
        df_alt_az_days = pd.DataFrame(_)
        df_alt_az_days.columns = ["altitude", "azimuth", "days", "hit", "miss"]
        #df_alt_az_days.reindex()
        return df_alt_az_days


    def invoke(self, dt: datetime, lat: float, lon: float):
        ''' Main logic for satellite hit-testing service

            Returns 2 DataFrames:
             - df_hit_miss_table :       The hit,miss stats table
             - df_alt_az_days_visible :  The information on the visible satellites for star-map plotting

        '''
        df_alt_az_days = self.satellite_alt_az_days(dt, lat, lon)

        # "invert" altitude for polar plotting.  Doing this thousands of times
        #  more than necessary (really just want R for the df_alt_az_days_visible slice)
        #  but pandas does not like apply on a slice.
        df_alt_az_days.loc["R"] = 90.0 - df_alt_az_days["altitude"]

        def apply_quality_str(row, col):
            q = ""
            if row[col] == Q_EXCELLENT:
                q = "Excellent"
            elif row[col] == Q_GOOD:
                q = "Good"
            elif row[col] == Q_POOR:
                q = "Poor"
            elif row[col] == Q_STALE:
                q = "Stale"
            # no-else ... leave the NaNs alone
            return q
        #

        df_hit_miss_table = pd.concat([
            df_alt_az_days["hit"].value_counts(sort=False),
            df_alt_az_days["miss"].value_counts()],
            axis=1, sort=False)

        df_alt_az_days_visible = df_alt_az_days[df_alt_az_days["altitude"] > self.𝜃]

        return df_hit_miss_table, df_alt_az_days_visible
    #

    def web_invoke(self, dt, lat, lon):
        ''' Main support function for satellite hit-testing service

            returns a json object having two objects:
            {
                "hitmiss": The hit,miss stats table
                "visible": The information on the visible satellites
            }
        '''
        df_hit_miss_table, df_alt_az_days_visible = self.invoke(dt, lat, lon)
        result = {
            "hitmiss": df_hit_miss_table.to_dict(),
            "visible": df_alt_az_days_visible.to_dict()
        }
        return json.dumps(result)
    #